{"ast":null,"code":"import { breakpointsValues as values, breakpointsValuesUnit as unit, breakpointKeys as keys } from \"./generatedFromCss/breakpoints\";\nimport { assert } from \"tsafe/assert\";\nimport { getBaseFontSizePx } from \"../tools/getBaseFontSizePx\";\nconst epsilon = 0.003125;\nexport const breakpoints = {\n  \"up\": key => `@media (min-width:${values[key]}${unit})`,\n  \"down\": key => `@media (max-width:${values[key] - epsilon}${unit})`,\n  \"between\": (start, end) => `@media (min-width:${values[start]}${unit}) and (max-width:${values[end] - epsilon}${unit})`,\n  \"only\": key => keys.indexOf(key) + 1 < keys.length ? breakpoints.between(key, keys[keys.indexOf(key) + 1]) : breakpoints.up((assert(key !== \"xs\"), key)),\n  \"not\": key => {\n    // handle first and last key separately, for better readability\n    const keyIndex = keys.indexOf(key);\n    if (keyIndex === 0) {\n      return breakpoints.up(keys[1]);\n    }\n    if (keyIndex === keys.length - 1) {\n      const key = keys[keyIndex];\n      assert(key !== \"xs\");\n      return breakpoints.down(key);\n    }\n    return breakpoints.between(key, keys[keys.indexOf(key) + 1]).replace(\"@media\", \"@media not all and\");\n  },\n  \"values\": (() => {\n    const out = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, (() => {\n      const key = \"xs\";\n      return {\n        [key]: `${values[key]}${unit}`\n      };\n    })()), (() => {\n      const key = \"sm\";\n      return {\n        [key]: `${values[key]}${unit}`\n      };\n    })()), (() => {\n      const key = \"md\";\n      return {\n        [key]: `${values[key]}${unit}`\n      };\n    })()), (() => {\n      const key = \"lg\";\n      return {\n        [key]: `${values[key]}${unit}`\n      };\n    })()), (() => {\n      const key = \"xl\";\n      return {\n        [key]: `${values[key]}${unit}`\n      };\n    })());\n    assert();\n    return out;\n  })(),\n  \"valuesUnit\": unit,\n  \"emValues\": (() => {\n    assert();\n    return values;\n  })(),\n  /**\n   * Returns the breakpoint values in px.\n   *\n   * Warning: It reflects the values at a given time, if the root font size changes so will the breakpointsValues.\n   * Plus this function is rather expensive to call.\n   * If you're in react you should use the\n   * import { useBreakpointsValuesPx } from \"@codegouvfr/react-dsfr/useBreakpointsValuesPx\";\n   */\n  \"getPxValues\": () => {\n    assert();\n    const factor = getBaseFontSizePx();\n    return Object.fromEntries(Object.entries(values).map(([key, value]) => [key, value * factor]));\n  },\n  /** @deprecated use breakpoints.values if you're ok with getting the value in em or breakpoints.getPxValues() if you want the value in pixel */\n  \"getBreakpointsValues\": () => breakpoints.getPxValues()\n};","map":{"version":3,"names":["breakpointsValues","values","breakpointsValuesUnit","unit","breakpointKeys","keys","assert","getBaseFontSizePx","epsilon","breakpoints","key","between","start","end","indexOf","length","up","keyIndex","down","replace","out","Object","assign","getPxValues","factor","fromEntries","entries","map","value","getBreakpointsValues"],"sources":["C:\\Users\\alban\\node_modules\\@codegouvfr\\react-dsfr\\src\\fr\\breakpoints.ts"],"sourcesContent":["import type { BreakpointKeys } from \"./generatedFromCss/breakpoints\";\nimport {\n    breakpointsValues as values,\n    breakpointsValuesUnit as unit,\n    breakpointKeys as keys\n} from \"./generatedFromCss/breakpoints\";\nimport { type Equals, assert } from \"tsafe/assert\";\nimport { getBaseFontSizePx } from \"../tools/getBaseFontSizePx\";\n\nexport type { BreakpointKeys };\n\n/** Breakpoint values in px */\nexport type BreakpointsValues = Record<BreakpointKeys, number>;\n\nconst epsilon = 0.003125;\n\nexport const breakpoints = {\n    \"up\": (key: Exclude<BreakpointKeys, \"xs\">) =>\n        `@media (min-width:${values[key]}${unit})` as const,\n    \"down\": (key: Exclude<BreakpointKeys, \"xs\">) =>\n        `@media (max-width:${values[key] - epsilon}${unit})` as const,\n    \"between\": (start: BreakpointKeys, end: BreakpointKeys) =>\n        `@media (min-width:${values[start]}${unit}) and (max-width:${\n            values[end] - epsilon\n        }${unit})` as const,\n    \"only\": (key: BreakpointKeys) =>\n        keys.indexOf(key) + 1 < keys.length\n            ? breakpoints.between(key, keys[keys.indexOf(key) + 1])\n            : breakpoints.up((assert(key !== \"xs\"), key)),\n    \"not\": (key: BreakpointKeys) => {\n        // handle first and last key separately, for better readability\n        const keyIndex = keys.indexOf(key);\n        if (keyIndex === 0) {\n            return breakpoints.up(keys[1]);\n        }\n        if (keyIndex === keys.length - 1) {\n            const key = keys[keyIndex];\n            assert(key !== \"xs\");\n            return breakpoints.down(key);\n        }\n\n        return breakpoints\n            .between(key, keys[keys.indexOf(key) + 1])\n            .replace(\"@media\", \"@media not all and\");\n    },\n    \"values\": (() => {\n        const out = {\n            ...(() => {\n                const key = \"xs\" satisfies BreakpointKeys;\n\n                return { [key]: `${values[key]}${unit}` as const };\n            })(),\n            ...(() => {\n                const key = \"sm\" satisfies BreakpointKeys;\n\n                return { [key]: `${values[key]}${unit}` as const };\n            })(),\n            ...(() => {\n                const key = \"md\" satisfies BreakpointKeys;\n\n                return { [key]: `${values[key]}${unit}` as const };\n            })(),\n            ...(() => {\n                const key = \"lg\" satisfies BreakpointKeys;\n\n                return { [key]: `${values[key]}${unit}` as const };\n            })(),\n            ...(() => {\n                const key = \"xl\" satisfies BreakpointKeys;\n\n                return { [key]: `${values[key]}${unit}` as const };\n            })()\n        } as const;\n\n        assert<Equals<keyof typeof out, BreakpointKeys>>();\n\n        return out;\n    })(),\n    \"valuesUnit\": unit,\n    \"emValues\": (() => {\n        assert<Equals<typeof unit, \"em\">>();\n\n        return values;\n    })(),\n    /**\n     * Returns the breakpoint values in px.\n     *\n     * Warning: It reflects the values at a given time, if the root font size changes so will the breakpointsValues.\n     * Plus this function is rather expensive to call.\n     * If you're in react you should use the\n     * import { useBreakpointsValuesPx } from \"@codegouvfr/react-dsfr/useBreakpointsValuesPx\";\n     */\n    \"getPxValues\": (): BreakpointsValues => {\n        assert<Equals<typeof unit, \"em\">>();\n\n        const factor = getBaseFontSizePx();\n\n        return Object.fromEntries(\n            Object.entries(values).map(([key, value]) => [key, value * factor])\n        ) as any;\n    },\n    /** @deprecated use breakpoints.values if you're ok with getting the value in em or breakpoints.getPxValues() if you want the value in pixel */\n    \"getBreakpointsValues\": () => breakpoints.getPxValues()\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}