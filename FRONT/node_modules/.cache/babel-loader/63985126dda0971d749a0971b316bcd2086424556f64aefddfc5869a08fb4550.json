{"ast":null,"code":"import { assert } from \"tsafe/assert\";\nimport { typeGuard } from \"tsafe/typeGuard\";\nexport const cx = (...args) => {\n  const len = args.length;\n  let i = 0;\n  let cls = \"\";\n  for (; i < len; i++) {\n    const arg = args[i];\n    if (arg == null) continue;\n    let toAdd;\n    switch (typeof arg) {\n      case \"boolean\":\n        break;\n      case \"object\":\n        {\n          if (Array.isArray(arg)) {\n            toAdd = cx(...arg);\n          } else {\n            assert(!typeGuard(arg, false));\n            toAdd = \"\";\n            for (const k in arg) {\n              if (arg[k] && k) {\n                toAdd && (toAdd += \" \");\n                toAdd += k;\n              }\n            }\n          }\n          break;\n        }\n      default:\n        {\n          toAdd = arg;\n        }\n    }\n    if (toAdd) {\n      cls && (cls += \" \");\n      cls += toAdd;\n    }\n  }\n  return cls;\n};","map":{"version":3,"names":["assert","typeGuard","cx","args","len","length","i","cls","arg","toAdd","Array","isArray","k"],"sources":["C:\\Users\\alban\\node_modules\\@codegouvfr\\react-dsfr\\src\\tools\\cx.ts"],"sourcesContent":["import { assert } from \"tsafe/assert\";\nimport { typeGuard } from \"tsafe/typeGuard\";\n\nexport type CxArg =\n    | undefined\n    | null\n    | string\n    | boolean\n    | Partial<Record<string, boolean | null | undefined>>\n    | readonly CxArg[];\n\nexport const cx = (...args: CxArg[]): string => {\n    const len = args.length;\n    let i = 0;\n    let cls = \"\";\n    for (; i < len; i++) {\n        const arg = args[i];\n        if (arg == null) continue;\n\n        let toAdd;\n        switch (typeof arg) {\n            case \"boolean\":\n                break;\n            case \"object\": {\n                if (Array.isArray(arg)) {\n                    toAdd = cx(...arg);\n                } else {\n                    assert(!typeGuard<{ length: number }>(arg, false));\n\n                    toAdd = \"\";\n                    for (const k in arg) {\n                        if (arg[k as string] && k) {\n                            toAdd && (toAdd += \" \");\n                            toAdd += k;\n                        }\n                    }\n                }\n                break;\n            }\n            default: {\n                toAdd = arg;\n            }\n        }\n        if (toAdd) {\n            cls && (cls += \" \");\n            cls += toAdd;\n        }\n    }\n    return cls;\n};\n"],"mappings":"AAAA,SAASA,MAAM,QAAQ,cAAc;AACrC,SAASC,SAAS,QAAQ,iBAAiB;AAU3C,OAAO,MAAMC,EAAE,GAAGA,CAAC,GAAGC,IAAa,KAAY;EAC3C,MAAMC,GAAG,GAAGD,IAAI,CAACE,MAAM;EACvB,IAAIC,CAAC,GAAG,CAAC;EACT,IAAIC,GAAG,GAAG,EAAE;EACZ,OAAOD,CAAC,GAAGF,GAAG,EAAEE,CAAC,EAAE,EAAE;IACjB,MAAME,GAAG,GAAGL,IAAI,CAACG,CAAC,CAAC;IACnB,IAAIE,GAAG,IAAI,IAAI,EAAE;IAEjB,IAAIC,KAAK;IACT,QAAQ,OAAOD,GAAG;MACd,KAAK,SAAS;QACV;MACJ,KAAK,QAAQ;QAAE;UACX,IAAIE,KAAK,CAACC,OAAO,CAACH,GAAG,CAAC,EAAE;YACpBC,KAAK,GAAGP,EAAE,CAAC,GAAGM,GAAG,CAAC;WACrB,MAAM;YACHR,MAAM,CAAC,CAACC,SAAS,CAAqBO,GAAG,EAAE,KAAK,CAAC,CAAC;YAElDC,KAAK,GAAG,EAAE;YACV,KAAK,MAAMG,CAAC,IAAIJ,GAAG,EAAE;cACjB,IAAIA,GAAG,CAACI,CAAW,CAAC,IAAIA,CAAC,EAAE;gBACvBH,KAAK,KAAKA,KAAK,IAAI,GAAG,CAAC;gBACvBA,KAAK,IAAIG,CAAC;;;;UAItB;;MAEJ;QAAS;UACLH,KAAK,GAAGD,GAAG;;;IAGnB,IAAIC,KAAK,EAAE;MACPF,GAAG,KAAKA,GAAG,IAAI,GAAG,CAAC;MACnBA,GAAG,IAAIE,KAAK;;;EAGpB,OAAOF,GAAG;AACd,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}