{"ast":null,"code":"/* eslint-disable @typescript-eslint/ban-types */\nimport { assert } from \"tsafe/assert\";\nimport { capitalize } from \"tsafe/capitalize\";\nimport { spacingTokenByValue } from \"./generatedFromCss/spacing\";\nexport function spacing(kindOrToken, params) {\n  if ([\"padding\", \"margin\"].indexOf(kindOrToken) >= 0) {\n    const kind = kindOrToken;\n    assert(params !== undefined);\n    const out = {};\n    const paramsWithOnlyDirection = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, (() => {\n      const {\n        rightLeft\n      } = params;\n      return rightLeft !== undefined && {\n        \"right\": rightLeft,\n        \"left\": rightLeft\n      };\n    })()), (() => {\n      const {\n        topBottom\n      } = params;\n      return topBottom !== undefined && {\n        \"top\": topBottom,\n        \"bottom\": topBottom\n      };\n    })()), params.top !== undefined && {\n      \"top\": params.top\n    }), params.right !== undefined && {\n      \"right\": params.right\n    }), params.bottom !== undefined && {\n      \"bottom\": params.bottom\n    }), params.left !== undefined && {\n      \"left\": params.left\n    });\n    [\"top\", \"right\", \"bottom\", \"left\"].forEach(p => {\n      const v = paramsWithOnlyDirection[p];\n      if (v === undefined) {\n        return;\n      }\n      out[`${kind}${capitalize(p)}`] = typeof v === \"number\" ? v : v === \"auto\" ? v : spacingTokenByValue[v];\n    });\n    return out;\n  } else {\n    const token = kindOrToken;\n    return spacingTokenByValue[token];\n  }\n}","map":{"version":3,"names":["assert","capitalize","spacingTokenByValue","spacing","kindOrToken","params","indexOf","kind","undefined","out","paramsWithOnlyDirection","Object","assign","rightLeft","topBottom","top","right","bottom","left","forEach","p","v","token"],"sources":["C:\\Users\\alban\\node_modules\\@codegouvfr\\react-dsfr\\src\\fr\\spacing.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/ban-types */\nimport { assert } from \"tsafe/assert\";\nimport { capitalize } from \"tsafe/capitalize\";\nimport { spacingTokenByValue } from \"./generatedFromCss/spacing\";\nimport type { SpacingToken, SpacingTokenByValue } from \"./generatedFromCss/spacing\";\n\nexport type { SpacingToken };\n\nexport function spacing<T extends SpacingToken>(token: T): SpacingTokenByValue[T];\nexport function spacing<\n    Kind extends \"padding\" | \"margin\",\n    Params extends Partial<\n        Record<\n            \"topBottom\" | \"rightLeft\" | \"top\" | \"right\" | \"bottom\" | \"left\",\n            SpacingToken | number | \"auto\"\n        >\n    >\n>(\n    kind: Kind,\n    params: Params\n): (Params extends { topBottom: SpacingToken | number | \"auto\" }\n    ? Record<\n          `${Kind}${\"Top\" | \"Bottom\"}`,\n          Params[\"topBottom\"] extends SpacingToken\n              ? SpacingTokenByValue[Params[\"topBottom\"]]\n              : Params[\"topBottom\"]\n      >\n    : {}) &\n    (Params extends { rightLeft: SpacingToken | number | \"auto\" }\n        ? Record<\n              `${Kind}${\"Right\" | \"Left\"}`,\n              Params[\"rightLeft\"] extends SpacingToken\n                  ? SpacingTokenByValue[Params[\"rightLeft\"]]\n                  : Params[\"rightLeft\"]\n          >\n        : {}) &\n    (Params extends { top: SpacingToken | number | \"auto\" }\n        ? Record<\n              `${Kind}Top`,\n              Params[\"top\"] extends SpacingToken\n                  ? SpacingTokenByValue[Params[\"top\"]]\n                  : Params[\"top\"]\n          >\n        : {}) &\n    (Params extends { right: SpacingToken | number | \"auto\" }\n        ? Record<\n              `${Kind}Right`,\n              Params[\"right\"] extends SpacingToken\n                  ? SpacingTokenByValue[Params[\"right\"]]\n                  : Params[\"right\"]\n          >\n        : {}) &\n    (Params extends { bottom: SpacingToken | number | \"auto\" }\n        ? Record<\n              `${Kind}Bottom`,\n              Params[\"bottom\"] extends SpacingToken\n                  ? SpacingTokenByValue[Params[\"bottom\"]]\n                  : Params[\"bottom\"]\n          >\n        : {}) &\n    (Params extends { left: SpacingToken | number | \"auto\" }\n        ? Record<\n              `${Kind}Left`,\n              Params[\"left\"] extends SpacingToken\n                  ? SpacingTokenByValue[Params[\"left\"]]\n                  : Params[\"left\"]\n          >\n        : {});\nexport function spacing(\n    kindOrToken: SpacingToken | \"padding\" | \"margin\",\n    params?: Partial<\n        Record<\n            \"topBottom\" | \"rightLeft\" | \"top\" | \"right\" | \"bottom\" | \"left\",\n            SpacingToken | number | \"auto\"\n        >\n    >\n): any {\n    if ([\"padding\", \"margin\"].indexOf(kindOrToken) >= 0) {\n        const kind = kindOrToken as \"padding\" | \"margin\";\n        assert(params !== undefined);\n\n        const out: any = {};\n\n        const paramsWithOnlyDirection = {\n            ...(() => {\n                const { rightLeft } = params;\n\n                return (\n                    rightLeft !== undefined && {\n                        \"right\": rightLeft,\n                        \"left\": rightLeft\n                    }\n                );\n            })(),\n            ...(() => {\n                const { topBottom } = params;\n\n                return (\n                    topBottom !== undefined && {\n                        \"top\": topBottom,\n                        \"bottom\": topBottom\n                    }\n                );\n            })(),\n            ...(params.top !== undefined && { \"top\": params.top }),\n            ...(params.right !== undefined && { \"right\": params.right }),\n            ...(params.bottom !== undefined && { \"bottom\": params.bottom }),\n            ...(params.left !== undefined && { \"left\": params.left })\n        };\n\n        ([\"top\", \"right\", \"bottom\", \"left\"] as const).forEach(p => {\n            const v = paramsWithOnlyDirection[p];\n\n            if (v === undefined) {\n                return;\n            }\n\n            out[`${kind}${capitalize(p)}`] =\n                typeof v === \"number\" ? v : v === \"auto\" ? v : spacingTokenByValue[v];\n        });\n\n        return out;\n    } else {\n        const token = kindOrToken as SpacingToken;\n\n        return spacingTokenByValue[token];\n    }\n}\n"],"mappings":"AAAA;AACA,SAASA,MAAM,QAAQ,cAAc;AACrC,SAASC,UAAU,QAAQ,kBAAkB;AAC7C,SAASC,mBAAmB,QAAQ,4BAA4B;AAiEhE,OAAM,SAAUC,OAAOA,CACnBC,WAAgD,EAChDC,MAKC;EAED,IAAI,CAAC,SAAS,EAAE,QAAQ,CAAC,CAACC,OAAO,CAACF,WAAW,CAAC,IAAI,CAAC,EAAE;IACjD,MAAMG,IAAI,GAAGH,WAAmC;IAChDJ,MAAM,CAACK,MAAM,KAAKG,SAAS,CAAC;IAE5B,MAAMC,GAAG,GAAQ,EAAE;IAEnB,MAAMC,uBAAuB,GAAAC,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACtB,CAAC,MAAK;MACL,MAAM;QAAEC;MAAS,CAAE,GAAGR,MAAM;MAE5B,OACIQ,SAAS,KAAKL,SAAS,IAAI;QACvB,OAAO,EAAEK,SAAS;QAClB,MAAM,EAAEA;OACX;IAET,CAAC,EAAC,CAAE,GACD,CAAC,MAAK;MACL,MAAM;QAAEC;MAAS,CAAE,GAAGT,MAAM;MAE5B,OACIS,SAAS,KAAKN,SAAS,IAAI;QACvB,KAAK,EAAEM,SAAS;QAChB,QAAQ,EAAEA;OACb;IAET,CAAC,EAAC,CAAE,GACAT,MAAM,CAACU,GAAG,KAAKP,SAAS,IAAI;MAAE,KAAK,EAAEH,MAAM,CAACU;IAAG,CAAG,GAClDV,MAAM,CAACW,KAAK,KAAKR,SAAS,IAAI;MAAE,OAAO,EAAEH,MAAM,CAACW;IAAK,CAAG,GACxDX,MAAM,CAACY,MAAM,KAAKT,SAAS,IAAI;MAAE,QAAQ,EAAEH,MAAM,CAACY;IAAM,CAAG,GAC3DZ,MAAM,CAACa,IAAI,KAAKV,SAAS,IAAI;MAAE,MAAM,EAAEH,MAAM,CAACa;IAAI,CAAG,CAC5D;IAEA,CAAC,KAAK,EAAE,OAAO,EAAE,QAAQ,EAAE,MAAM,CAAW,CAACC,OAAO,CAACC,CAAC,IAAG;MACtD,MAAMC,CAAC,GAAGX,uBAAuB,CAACU,CAAC,CAAC;MAEpC,IAAIC,CAAC,KAAKb,SAAS,EAAE;QACjB;;MAGJC,GAAG,CAAC,GAAGF,IAAI,GAAGN,UAAU,CAACmB,CAAC,CAAC,EAAE,CAAC,GAC1B,OAAOC,CAAC,KAAK,QAAQ,GAAGA,CAAC,GAAGA,CAAC,KAAK,MAAM,GAAGA,CAAC,GAAGnB,mBAAmB,CAACmB,CAAC,CAAC;IAC7E,CAAC,CAAC;IAEF,OAAOZ,GAAG;GACb,MAAM;IACH,MAAMa,KAAK,GAAGlB,WAA2B;IAEzC,OAAOF,mBAAmB,CAACoB,KAAK,CAAC;;AAEzC"},"metadata":{},"sourceType":"module","externalDependencies":[]}