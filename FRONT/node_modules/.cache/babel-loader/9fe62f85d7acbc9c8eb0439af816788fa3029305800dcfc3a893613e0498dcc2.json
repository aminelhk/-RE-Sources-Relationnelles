{"ast":null,"code":"import { assert } from \"tsafe/assert\";\nimport { is } from \"tsafe/is\";\nexport function createStatefulObservable(getInitialValue) {\n  const nextFunctions = [];\n  const {\n    get,\n    set\n  } = (() => {\n    let wrappedState = undefined;\n    function set(data) {\n      wrappedState = [data];\n      nextFunctions.forEach(next => next(data));\n    }\n    return {\n      \"get\": () => {\n        if (wrappedState === undefined) {\n          set(getInitialValue());\n          assert(!is(wrappedState));\n        }\n        return wrappedState[0];\n      },\n      set\n    };\n  })();\n  return Object.defineProperty({\n    \"current\": null,\n    \"subscribe\": next => {\n      nextFunctions.push(next);\n      return {\n        \"unsubscribe\": () => nextFunctions.splice(nextFunctions.indexOf(next), 1)\n      };\n    }\n  }, \"current\", {\n    \"enumerable\": true,\n    get,\n    set\n  });\n}","map":{"version":3,"names":["assert","is","createStatefulObservable","getInitialValue","nextFunctions","get","set","wrappedState","undefined","data","forEach","next","Object","defineProperty","push","unsubscribe","splice","indexOf"],"sources":["C:\\Users\\alban\\node_modules\\@codegouvfr\\react-dsfr\\src\\tools\\StatefulObservable\\StatefulObservable.ts"],"sourcesContent":["import { assert } from \"tsafe/assert\";\nimport { is } from \"tsafe/is\";\n\nexport type StatefulObservable<T> = {\n    current: T;\n    subscribe: (next: (data: T) => void) => Subscription;\n};\n\nexport type Subscription = {\n    unsubscribe(): void;\n};\n\nexport function createStatefulObservable<T>(getInitialValue: () => T): StatefulObservable<T> {\n    const nextFunctions: ((data: T) => void)[] = [];\n\n    const { get, set } = (() => {\n        let wrappedState: [T] | undefined = undefined;\n\n        function set(data: T) {\n            wrappedState = [data];\n\n            nextFunctions.forEach(next => next(data));\n        }\n\n        return {\n            \"get\": () => {\n                if (wrappedState === undefined) {\n                    set(getInitialValue());\n                    assert(!is<undefined>(wrappedState));\n                }\n                return wrappedState[0];\n            },\n            set\n        };\n    })();\n\n    return Object.defineProperty(\n        {\n            \"current\": null as any as T,\n            \"subscribe\": (next: (data: T) => void) => {\n                nextFunctions.push(next);\n\n                return {\n                    \"unsubscribe\": () => nextFunctions.splice(nextFunctions.indexOf(next), 1)\n                };\n            }\n        },\n        \"current\",\n        {\n            \"enumerable\": true,\n            get,\n            set\n        }\n    );\n}\n"],"mappings":"AAAA,SAASA,MAAM,QAAQ,cAAc;AACrC,SAASC,EAAE,QAAQ,UAAU;AAW7B,OAAM,SAAUC,wBAAwBA,CAAIC,eAAwB;EAChE,MAAMC,aAAa,GAA0B,EAAE;EAE/C,MAAM;IAAEC,GAAG;IAAEC;EAAG,CAAE,GAAG,CAAC,MAAK;IACvB,IAAIC,YAAY,GAAoBC,SAAS;IAE7C,SAASF,GAAGA,CAACG,IAAO;MAChBF,YAAY,GAAG,CAACE,IAAI,CAAC;MAErBL,aAAa,CAACM,OAAO,CAACC,IAAI,IAAIA,IAAI,CAACF,IAAI,CAAC,CAAC;IAC7C;IAEA,OAAO;MACH,KAAK,EAAEJ,CAAA,KAAK;QACR,IAAIE,YAAY,KAAKC,SAAS,EAAE;UAC5BF,GAAG,CAACH,eAAe,EAAE,CAAC;UACtBH,MAAM,CAAC,CAACC,EAAE,CAAYM,YAAY,CAAC,CAAC;;QAExC,OAAOA,YAAY,CAAC,CAAC,CAAC;MAC1B,CAAC;MACDD;KACH;EACL,CAAC,EAAC,CAAE;EAEJ,OAAOM,MAAM,CAACC,cAAc,CACxB;IACI,SAAS,EAAE,IAAgB;IAC3B,WAAW,EAAGF,IAAuB,IAAI;MACrCP,aAAa,CAACU,IAAI,CAACH,IAAI,CAAC;MAExB,OAAO;QACH,aAAa,EAAEI,CAAA,KAAMX,aAAa,CAACY,MAAM,CAACZ,aAAa,CAACa,OAAO,CAACN,IAAI,CAAC,EAAE,CAAC;OAC3E;IACL;GACH,EACD,SAAS,EACT;IACI,YAAY,EAAE,IAAI;IAClBN,GAAG;IACHC;GACH,CACJ;AACL"},"metadata":{},"sourceType":"module","externalDependencies":[]}